- [NWPU compiler试点班第一次作业](#nwpu-compiler%e8%af%95%e7%82%b9%e7%8f%ad%e7%ac%ac%e4%b8%80%e6%ac%a1%e4%bd%9c%e4%b8%9a)
  - [文法熟悉](#%e6%96%87%e6%b3%95%e7%86%9f%e6%82%89)
    - [**C0文法**](#c0%e6%96%87%e6%b3%95)
    - [**扩充C0文法**](#%e6%89%a9%e5%85%85c0%e6%96%87%e6%b3%95)
  - [步骤](#%e6%ad%a5%e9%aa%a4)
    - [**词法分析器**](#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8)
    - [**语法分析器**](#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8)
    - [**中间代码生成器**](#%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90%e5%99%a8)
  - [相关工具](#%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7)
    - [**lex**](#lex)
    - [**yacc**](#yacc)
    - [**flex**](#flex)
    - [**bison**](#bison)
    - [**javacc**](#javacc)
    - [**antrl**](#antrl)
  - [对相关工具的熟悉](#%e5%af%b9%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7%e7%9a%84%e7%86%9f%e6%82%89)
    - [**JavaCC**](#javacc-1)
    - [**flex**](#flex-1)
  - [在读懂代码的基础上做一些修改](#%e5%9c%a8%e8%af%bb%e6%87%82%e4%bb%a3%e7%a0%81%e7%9a%84%e5%9f%ba%e7%a1%80%e4%b8%8a%e5%81%9a%e4%b8%80%e4%ba%9b%e4%bf%ae%e6%94%b9)
  - [目前遇到的问题](#%e7%9b%ae%e5%89%8d%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98)

# NWPU compiler试点班第一次作业
* 首先先确定什么是C0文法，什么是扩展的C0文法；
* 然后确定文法分析的步骤和各个步骤的输入输出。
* 查看有哪些工具，可以减少工作量
## 文法熟悉
### **C0文法**
* <程序> -> [<变量定义部分>] {<自定义函数定义部分>} <主函数>
* <变量定义部分> -> int id {, id};
* <自定义函数定义部分> -> ( int id | void id) '(' ')' <分程序>
* <主函数> -> void main'(' ')' <分程序>
* <分程序> -> '{' [<变量定义部分>] <语句序列> '}'
* <语句序列> -> <语句> {<语句>}
* <语句> -> <条件语句> | <循环语句> | '{'<语句序列>'}' | <自定义函数调用语句> | <赋值语句> | <返回语句> | <读语句> | <写语句> | ;
* <条件语句> -> if '('<表达式>')' <语句> [else <语句> ]
* <循环语句> -> while '(' <表达式>')' <语句>
* <自定义函数调用语句> -> <自定义函数调用>;
* <赋值语句> -> id = <表达式>;
* <返回语句> -> return ['(' <表达式> ')'] ;
* <读语句> -> scanf '(' id ')';
* <写语句> -> printf '(' [ <表达式>] ')';
* <表达式> -> [+｜-] <项> { (+｜-) <项>}
* <项> -> <因子>｛(*｜/) <因子>｝
* <因子> -> id｜'(' <表达式>')' | num | <自定义函数调用>
* <自定义函数调用> -> id '(' ')'
### **扩充C0文法**
~~~c++
BNF格式
<符号> ::= <使用符号的表达式>
//这里的 <符号> 是非终结符，而表达式由一个符号序列，或用指示选择的竖杠 '|' 分隔的多个符号序列构成，每个符号序列整体都是左端的符号的一种可能的替代。从未在左端出现的符号叫做终结符
~~~
* ＜加法运算符＞ ::= +｜-
* ＜乘法运算符＞  ::= *｜/
* ＜关系运算符＞  ::=  <｜<=｜>｜>=｜!=｜==
* ＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
* ＜数字＞   ::= ０｜＜非零数字＞
* ＜非零数字＞  ::= １｜．．．｜９
* ＜字符＞    ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
* ＜字符串＞   ::=  "｛十进制编码为32,33,35-126的ASCII字符｝"                              
* ＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞
* ＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;}
* ＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞}| char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}
* ＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝
* ＜整数＞        ::= ［＋｜－］＜无符号整数＞｜0
* ＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝
* ＜声明头部＞   ::=  int＜标识符＞|char＜标识符＞
* ＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}
* ＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞‘[’＜无符号整数＞‘]’){,(＜标识符＞|＜标识符＞‘[’＜无符号整数＞‘]’) }
* ＜类型标识符＞      ::=  int | char
* ＜有返回值函数定义＞  ::=  ＜声明头部＞‘(’＜参数＞‘)’ ‘{’＜复合语句＞‘}’
* ＜无返回值函数定义＞  ::= void＜标识符＞‘(’＜参数＞‘)’‘{’＜复合语句＞‘}’
* ＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞
* ＜参数＞    ::= ＜参数表＞
* ＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞
* ＜主函数＞    ::= void main‘(’‘)’ ‘{’＜复合语句＞‘}’
* ＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}
* ＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞}
* ＜因子＞    ::= ＜标识符＞｜＜标识符＞‘[’＜表达式＞‘]’｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞|‘(’＜表达式＞‘)’
* ＜语句＞    ::= ＜条件语句＞｜＜循环语句＞｜‘{’＜语句列＞‘}’｜＜有返回值函数调用语句＞; |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜<空＞;｜＜返回语句＞;
* ＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞‘[’＜表达式＞‘]’=＜表达式＞
* ＜条件语句＞  ::=  if ‘(’＜条件＞‘)’＜语句＞［else＜语句＞］
* ＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞｜＜表达式＞ 
* ＜循环语句＞   ::=  do＜语句＞while ‘(’＜条件＞‘)’ |for‘(’＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞‘)’＜语句＞
* ＜步长＞::= ＜无符号整数＞  
* ＜有返回值函数调用语句＞ ::= ＜标识符＞‘(’＜值参数表＞‘)’
* ＜无返回值函数调用语句＞ ::= ＜标识符＞‘(’＜值参数表＞‘)’
* ＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}｜＜空＞
* ＜语句列＞   ::=｛＜语句＞｝
* ＜读语句＞    ::=  scanf ‘(’＜标识符＞{,＜标识符＞}‘)’
* ＜写语句＞    ::=  printf‘(’＜字符串＞,＜表达式＞‘)’|printf ‘(’＜字符串＞‘)’|printf ‘(’＜表达式＞‘)’
* ＜返回语句＞   ::=  return[‘(’＜表达式＞‘)’]
## 步骤
### **词法分析器**
* input - 源程序
* output- 获得Token输出流
### **语法分析器**
* input - Token序列
* output- 抽象语法树
### **中间代码生成器**
* input -
* output-
## 相关工具
### **lex**
词法分析器的产生器
### **yacc**
用C开发的生成语法分析器的工具,经常与词法分析器lex一起使用。输入是BNF表达的语法规则以及语法规约的处理代码，输出是基于表驱动的编译器。
### **flex**
flex是lex的进化版
### **bison**
bison是yacc的进化版
### **javacc**
用java开发的语法分析生成器，并且提供JJTree工具来帮助建立语法树，JJDoc工具为源文件生成BNF范式文档(Html)，基于自上而下算法对CFG解析。
### **antrl**
类似JavaCC
## 对相关工具的熟悉
### **JavaCC**
先写了一个简单Integer的Adder,熟悉下语法
首先对一个github上的C0项目编译测试一下，然后看代码
### **flex**
看了youtube上的一个教程，看到flex的输出结果中有一个表驱动的词法分析器，就先利用表生成TOKEN流
## 在读懂代码的基础上做一些修改
1. 添加单行与多行注释的支持
  
## 目前遇到的问题
1. javacc的输出不支持中文，即使加了options的UNICODE_INPUT=true;
2. git上的代码是一个C0文法的，希望用两天左右的时间更改为扩充的C0文法。
